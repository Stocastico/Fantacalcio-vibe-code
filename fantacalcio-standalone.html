<!doctype html>
<html lang="it">

<head>
    <meta charset="utf-8" />
    <title>Fantacalcio – Helper d'Asta (offuscato)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
        :root {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            --primary: #6366f1;
            --primary-light: #a5b4fc;
            --primary-dark: #4338ca;
            --secondary: #10b981;
            --warning: #f59e0b;
            --danger: #ef4444;
            --surface: #ffffff;
            --surface-2: #f8fafc;
            --surface-3: #f1f5f9;
            --border: #e2e8f0;
            --text: #1e293b;
            --text-muted: #64748b;
            --shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        body {
            margin: 0;
            padding: 24px;
            background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
            min-height: 100vh;
            color: var(--text);
            line-height: 1.6;
        }

        h1 {
            margin-bottom: 8px;
            color: var(--primary-dark);
            font-weight: 700;
            font-size: 2rem;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .muted {
            color: var(--text-muted);
            font-size: 14px;
            font-weight: 400;
        }

        .pill {
            display: inline-block;
            padding: 8px 16px;
            margin: 4px;
            background: var(--surface);
            color: var(--text);
            border-radius: 20px;
            font-size: 13px;
            font-weight: 500;
            border: 1px solid var(--border);
            box-shadow: var(--shadow);
            transition: all 0.2s ease;
        }

        .pill:nth-child(1) {
            background: linear-gradient(135deg, #fef3c7, #fbbf24);
            color: #92400e;
        }

        .pill:nth-child(2) {
            background: linear-gradient(135deg, #dbeafe, #3b82f6);
            color: #1e40af;
        }

        .pill:nth-child(3) {
            background: linear-gradient(135deg, #dcfce7, #22c55e);
            color: #166534;
        }

        .pill:nth-child(4) {
            background: linear-gradient(135deg, #fce7f3, #ec4899);
            color: #be185d;
        }

        .pill:nth-child(5) {
            background: linear-gradient(135deg, #f3e8ff, #a855f7);
            color: #7c2d12;
        }

        .pill:nth-child(6) {
            background: linear-gradient(135deg, #e0f2fe, #06b6d4);
            color: #0e7490;
        }

        .pill:nth-child(7) {
            background: linear-gradient(135deg, #fff1f2, #f43f5e);
            color: #be123c;
        }

        .row {
            display: flex;
            gap: 12px;
            align-items: center;
            margin-top: 12px;
            flex-wrap: wrap;
        }

        .card {
            border: 1px solid var(--border);
            border-radius: 16px;
            padding: 24px;
            background: var(--surface);
            box-shadow: var(--shadow-lg);
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }

        .card:hover {
            transform: translateY(-2px);
            box-shadow: 0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1);
        }

        .grid {
            display: grid;
            gap: 20px;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
        }

        .warn {
            color: var(--danger);
            font-weight: 600;
        }

        .ok {
            color: var(--secondary);
            font-weight: 600;
        }

        .out {
            margin-top: 16px;
            padding: 16px 20px;
            background: var(--surface-2);
            border-radius: 12px;
            min-height: 50px;
            white-space: pre-wrap;
            border: 1px solid var(--border);
            font-size: 14px;
            box-shadow: inset 0 2px 4px 0 rgb(0 0 0 / 0.06);
        }

        label {
            font-size: 15px;
            font-weight: 600;
            display: block;
            margin-bottom: 8px;
            color: var(--text);
        }

        input[type=text],
        input[type=password],
        input[type=number] {
            width: 100%;
            padding: 12px 16px;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--surface);
            font-size: 15px;
            transition: all 0.2s ease;
            box-shadow: var(--shadow);
        }

        input[type=text]:focus,
        input[type=password]:focus,
        input[type=number]:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgb(99 102 241 / 0.1);
        }

        button {
            padding: 12px 20px;
            border: none;
            border-radius: 12px;
            background: linear-gradient(135deg, var(--primary), var(--primary-dark));
            color: white;
            cursor: pointer;
            font-weight: 600;
            font-size: 14px;
            transition: all 0.2s ease;
            box-shadow: var(--shadow);
        }

        button:hover {
            transform: translateY(-1px);
            box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        button:active {
            transform: translateY(0);
        }

        button.secondary {
            background: var(--surface);
            color: var(--text);
            border: 2px solid var(--border);
        }

        button.secondary:hover {
            background: var(--surface-2);
            border-color: var(--primary-light);
        }

        button.emergency {
            background: linear-gradient(135deg, var(--danger), #dc2626);
            color: white;
            border: none;
            font-weight: 700;
            box-shadow: 0 4px 14px 0 rgb(239 68 68 / 0.39);
        }

        button.emergency:hover {
            background: linear-gradient(135deg, #dc2626, #b91c1c);
            box-shadow: 0 6px 20px 0 rgb(239 68 68 / 0.5);
        }

        button.emergency:active {
            background: linear-gradient(135deg, #b91c1c, #991b1b);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }

        .layout {
            display: grid;
            gap: 24px;
            grid-template-columns: 1fr;
        }

        @media (min-width:980px) {
            .layout {
                grid-template-columns: 1fr 360px;
                align-items: start;
            }

            .sidebar {
                position: sticky;
                top: 24px;
            }
        }

        ul.list {
            list-style: none;
            padding-left: 0;
            margin: 16px 0 0;
        }

        ul.list li {
            padding: 12px 16px;
            border-bottom: 1px solid var(--border);
            border-radius: 8px;
            margin-bottom: 4px;
            background: var(--surface-2);
            transition: all 0.2s ease;
            font-weight: 500;
        }

        ul.list li:hover {
            background: var(--surface-3);
            transform: translateX(4px);
        }

        ul.list li:last-child {
            border-bottom: none;
        }

        .flash-add {
            animation: flashAdd 1.8s ease-out;
        }

        @keyframes flashAdd {
            0% {
                background: linear-gradient(135deg, #fef3c7, #fbbf24);
                transform: scale(1.02);
            }

            30% {
                background: linear-gradient(135deg, #fef3c7, #fbbf24);
            }

            70% {
                background: var(--surface-2);
            }

            100% {
                background: var(--surface-2);
                transform: scale(1);
            }
        }

        h3 {
            color: var(--primary-dark);
            font-weight: 700;
            margin-top: 0;
        }

        h4 {
            color: var(--text);
            font-weight: 600;
        }

        details {
            margin-top: 12px;
        }

        summary {
            cursor: pointer;
            padding: 8px 12px;
            background: var(--surface-2);
            border-radius: 8px;
            font-weight: 600;
            color: var(--primary-dark);
            transition: all 0.2s ease;
        }

        summary:hover {
            background: var(--surface-3);
            color: var(--primary);
        }

        /* Special styling for auction section */
        #auctionSection {
            background: linear-gradient(135deg, #eff6ff, #dbeafe) !important;
            border: 2px solid var(--primary-light) !important;
            box-shadow: 0 0 0 3px rgb(99 102 241 / 0.1) !important;
        }
    </style>
</head>

<body>
    <h1>Fantacalcio – Helper d'Asta</h1>
    <p class="muted">
        Lista <strong>offuscata</strong> con passphrase. Non è cifratura forte, ma scoraggia chi apre il sorgente.
    </p>

    <!-- BLOCCO SBLOCCO -->
    <div id="locked" class="card" style="max-width:580px;">
        <h3>Sblocca la lista</h3>
        <label for="pw">Passphrase</label>
        <input id="pw" type="password" placeholder="Inserisci passphrase" />
        <div class="row">
            <button id="btnUnlock">Sblocca</button>
        </div>
        <div id="outUnlock" class="out"></div>
        <p class="muted">Dopo lo sblocco, la pagina funziona offline come l'helper normale.</p>
    </div>

    <!-- APP -->
    <div id="app" style="display:none;">
        <div class="row">
            <span class="pill" id="countP">P: 0</span>
            <span class="pill" id="countD">D: 0</span>
            <span class="pill" id="countC">C: 0</span>
            <span class="pill" id="countA">A: 0</span>
            <span class="pill" id="sumNow">Somma tetti: 0</span>
            <span class="pill" id="budgetLeft">Crediti residui: 500</span>
            <span class="pill" id="playersLeft">Giocatori rimanenti: 0</span>
        </div>

        <div class="layout" style="margin-top:16px;">
            <!-- SINISTRA: strumenti base -->
            <div>
                <div class="grid">
                    <!-- 1) CERCA -->
                    <section class="card">
                        <h3>1) Fai offerta per un giocatore</h3>

                        <!-- Random player selection -->
                        <div style="margin-bottom:16px;">
                            <p class="muted">Estrai un giocatore a caso dalla tua lista e inizia l'asta con offerta di 1
                                credito:</p>
                            <div class="row">
                                <button id="btnRandom">Estrai e inizia asta</button>
                                <button id="btnShowLeft" class="emergency">⚠️ Mostra lista rimanente</button>
                                <button id="btnReset" class="secondary"
                                    title="Ripristina lista originale">Reset</button>
                            </div>
                            <div id="outRandom" class="out"></div>
                            <details id="leftWrap" style="display:none; margin-top:8px;">
                                <summary>Lista rimanente</summary>
                                <div id="leftList" class="muted"></div>
                            </details>
                        </div>

                        <!-- Separator -->
                        <div style="text-align:center; margin:20px 0; font-size:1.2em; font-weight:bold; color:#666;">
                            Oppure
                        </div>

                        <!-- Manual search -->
                        <div>
                            <label for="q">Nome giocatore</label>
                            <input id="q" type="text" placeholder="es. Lautaro, Dybala, Zaccagni..." />
                            <div class="row">
                                <button id="btnCheck">Cerca nella mia lista</button>
                                <button id="btnClear" class="secondary">Pulisci</button>
                            </div>
                            <div id="outCheck" class="out"></div>
                        </div>

                        <!-- Auction bidding section (hidden initially) -->
                        <div id="auctionSection"
                            style="display:none; margin-top:12px; padding:12px; background:#f0f8ff; border-radius:8px;">
                            <h4 style="margin-top:0;">🏷️ Asta in corso</h4>
                            <div id="playerInfo" style="margin-bottom:8px; font-weight:bold;"></div>
                            <label for="currentOffer">Offerta attuale in asta</label>
                            <input id="currentOffer" type="number" inputmode="numeric" min="1" step="1"
                                placeholder="es. 25" />
                            <div class="row" style="margin-top:8px;">
                                <button id="btnCalculateBid">Calcola mia offerta</button>
                                <button id="btnPlayerWon" class="secondary">Giocatore acquisito</button>
                                <button id="btnPlayerLost" class="secondary">Giocatore andato</button>
                            </div>
                            <div id="outAuction" class="out"></div>
                        </div>

                        <p class="muted">Se il nome è ambiguo oppure parziale, ti suggerisco i match possibili.</p>
                    </section>
                </div>
            </div>

            <!-- DESTRA: sidebar acquisti -->
            <aside class="sidebar">
                <section class="card">
                    <h3>Rosa acquistata</h3>
                    <p class="muted">Giocatori acquisiti tramite asta. Usa la sezione "Cerca giocatore e asta" per
                        aggiungere
                        nuovi acquisti.</p>

                    <ul id="purchasesList" class="list"></ul>

                    <div class="row" style="margin-top:12px;">
                        <span class="pill" id="spentPill">Speso: 0</span>
                        <span class="pill" id="leftPill">Residuo: 500</span>
                    </div>

                    <div class="row" style="margin-top:8px;">
                        <button id="btnUndoBuy" class="secondary">Annulla ultimo</button>
                        <button id="btnExportCSV" class="secondary">Esporta CSV</button>
                    </div>

                    <div id="outBuy" class="out"></div>
                </section>
            </aside>
        </div>

        <details class="card" style="margin-top:16px;">
            <summary>Avanzato: re-offusca con nuova passphrase</summary>
            <p class="muted">
                Dopo lo sblocco, puoi inserire una nuova passphrase e ottenere una stringa offuscata da sostituire nel
                file
                (variabile <code>OBF</code>).
                Questo non salva automaticamente: copia/incolla manualmente.
            </p>
            <label for="newpw">Nuova passphrase</label>
            <input id="newpw" type="password" placeholder="Nuova passphrase" />
            <div class="row">
                <button id="btnReObf">Genera nuova stringa offuscata</button>
            </div>
            <div id="outReObf" class="out"></div>
        </details>
    </div>

    <script>
        // === DATA OBFUSCATA ===
        // Version 8 - Passphrase: "dammi un Braulio"
        // Updated with comprehensive credit redistribution tests
        const OBF = "BueD+8FfsC3ZOorcIq9LSmWQDRmNoq2d16LwFFPBCl8U0IPHmG93hsGGpegbbhb+QuNVXJVVbVon1zopU88KTc2Yg+/JVm1F1pVw9ti6PUllkBsZb6izmSnR8PBTB1dpEI6br7AUdy0Bgaid8IFZCHuQT1iImGNy18IvNKH2S2we4MKvjBS9egt9ZrXYkP4IItBKWz1tcm0ylEnmn/ZVYs2mg9TBZr90wURm7SW4Qf46kCUZR1WjoRmKCPVlEhR4zdrC+sUUhS3vh7feHm4I/nLdTVw9bWN815TwJpr5Cjfcnd652xS5bAx9ZrXYnD1OaeFKGUdVs6chzfD+U9kKKc3OyvGCLHw7HES/nSStSUEiqAM7ipyoWuGKQDOd+go3zbCDuYJUtG/BUnWrM3hX/m7PTlw9bWOOFtQzNpq3FB8d283ygixtT8FEZt0fsP4WOOsNcj2hoqUaigjmi/ZYbQyOja/SYbdwwVJmv9h4/j5p0gMxU7Bts9fWLzGWtyIf7dHN+cFguoEAOnCdKLtIQSKoAzs9X2OaHszw/mLGZSkmjs/uzVdtRcFlp88luUVKYecDIz2lsKQaigjmdLcUHw3Vxa+aJoCIy5Nm6Re5Qf46kCxmiqOunR7WMzaktxQfHdvN8oIsbU7BRGbdH7D+FjKmXiOWVa+ZIs3w/lPbTW8S4dT8zhR3LRGHsODYhv4fIpoDWYSXY3LnmkvwrLdWXhjRg8eCQqx+AISt3th4/k5v2kYZVVWEWuGKMC2VtyIu5OmNCIJgrHgEOn6dA7dERXTPU3B8oWNk19o9MJa3Ih/ujo2vwluvLdlJfPjix/5KYdtGGVVVg6oa2zEtkgNRaxSOja/SYbdwwVJmvth4/j5p0gMxTGi+ZDCKPCWe+go3za7C+cRTuYUIOnCdKLtIQSKoAzo9X2OaHszw/mLIZSkmjs/uzVdtRcFhsOQZbgj+ct1NXD1tY3vXlPAmmvkKN9yc3rnbFLlsDH1mtdiYPVF0z1NmO4CiqikrezKWDwopzd7Q+cUUhS3gOnCdGLVA/jqnEXRHrmOmFtUz5mu3PGUg3sL6gh5tfQ6EqZ3wbh3+LJBDYH9Ve23l5fo/UwNJahCOm6+2XqxzDo6tPz1uCP5y3U1cPW1jedeU8Caa+Qo33qHeudsUuWwMfWa12J8/PW3PRFp8VW1aJ9c6KVPPCj7NmIPvyVZtRdFKwacxbko9bdMDMT2Cs6sk1DcymrcUHx3bzfKCLG1MwURm3R+w/hYxoV4jllWvmSLN8P5T70lgDs3I+8kUdy0Rh7Dg2Ib+HSKaA1mEl2Ny5ptLIQ==";

        // Utils
        async function sha256Bytes(str) { const enc = new TextEncoder().encode(str); const hash = await crypto.subtle.digest("SHA-256", enc); return new Uint8Array(hash); }
        function b64ToBytes(b64) { const bin = atob(b64); const out = new Uint8Array(bin.length); for (let i = 0; i < bin.length; i++)out[i] = bin.charCodeAt(i); return out; }
        function bytesToB64(bytes) { let bin = ""; for (let i = 0; i < bytes.length; i++)bin += String.fromCharCode(bytes[i]); return btoa(bin); }
        function deobfuscate(obf, key) { const out = new Uint8Array(obf.length); for (let i = 0; i < obf.length; i++)out[i] = (obf[i] - key[i % key.length] + 256) % 256; return out; }
        function obfuscate(plain, key) { const out = new Uint8Array(plain.length); for (let i = 0; i < plain.length; i++)out[i] = (plain[i] + key[i % key.length]) % 256; return out; }

        // State
        let ORIGINAL = null, roster = null; const START_BUDGET = 500; let purchases = []; let spent = 0; let currentAuctionPlayer = null; let lastSuggestedBid = null;
        const norm = s => (s || "").normalize("NFD").replace(/\p{Diacritic}/gu, "").toLowerCase().replace(/\s+/g, " ").trim();
        const sumBid = list => list.reduce((a, x) => a + (x.bid || 0), 0);
        const countsByRole = list => list.reduce((m, x) => (m[x.role] = (m[x.role] || 0) + 1, m), { P: 0, D: 0, C: 0, A: 0 });

        function updateCounters() {
            if (!roster) return;
            const c = countsByRole(roster);
            document.getElementById("countP").textContent = `P: ${c.P}`;
            document.getElementById("countD").textContent = `D: ${c.D}`;
            document.getElementById("countC").textContent = `C: ${c.C}`;
            document.getElementById("countA").textContent = `A: ${c.A}`;
            document.getElementById("sumNow").textContent = `Somma tetti: ${sumBid(roster)}`;
            document.getElementById("budgetLeft").textContent = `Crediti residui: ${START_BUDGET - spent}`;
            document.getElementById("playersLeft").textContent = `Giocatori rimanenti: ${roster.length}`;
            document.getElementById("spentPill").textContent = `Speso: ${spent}`;
            document.getElementById("leftPill").textContent = `Residuo: ${START_BUDGET - spent}`;
        }

        // Variante 'ext': non mostra il tetto massimo/prezzo stimato
        const formatPlayer = p => `${p.name} - ${p.role}`;

        function listRemaining() {
            const order = { P: 0, D: 1, C: 2, A: 3 };
            return [...roster].sort((a, b) => (order[a.role] - order[b.role]) || (b.bid - a.bid) || a.name.localeCompare(b.name)).map(formatPlayer).join("\n");
        }

        function findCandidates(q, inList = roster) {
            const s = norm(q);
            if (!s) return [];
            const exact = inList.filter(p => norm(p.name) === s);
            if (exact.length === 1) return exact;
            return inList.filter(p => norm(p.name).includes(s));
        }

        function redistributeCredits(savedCredits, purchasedPlayerName) {
            if (savedCredits <= 0 || !roster || roster.length === 0) return 0;

            // Get remaining players (excluding the one just purchased) sorted by max bid (highest first)
            const remainingPlayers = roster
                .filter(p => norm(p.name) !== norm(purchasedPlayerName))
                .sort((a, b) => (b.bid || 0) - (a.bid || 0));

            let creditsToDistribute = Math.min(savedCredits, remainingPlayers.length);
            let distributed = 0;

            // Add +1 to the most expensive players until credits run out
            for (let i = 0; i < creditsToDistribute && i < remainingPlayers.length; i++) {
                remainingPlayers[i].bid = (remainingPlayers[i].bid || 0) + 1;
                distributed++;
            }

            return distributed;
        }

        function redistributeCreditsOnLoss(lostPlayer) {
            if (!lostPlayer || !roster || roster.length === 0) return 0;

            // Get all remaining players (excluding the lost one) sorted by max bid (highest first)
            const remainingPlayers = roster
                .filter(p => norm(p.name) !== norm(lostPlayer.name))
                .sort((a, b) => (b.bid || 0) - (a.bid || 0));

            if (remainingPlayers.length === 0) return 0;

            const creditsToRedistribute = lostPlayer.bid || 0;
            let creditsToDistribute = Math.min(creditsToRedistribute, remainingPlayers.length);
            let distributed = 0;

            // Add +1 to the most expensive players until credits run out
            for (let i = 0; i < creditsToDistribute && i < remainingPlayers.length; i++) {
                remainingPlayers[i].bid = (remainingPlayers[i].bid || 0) + 1;
                distributed++;
            }

            return distributed;
        }

        function addPurchase(name, price) {
            const out = document.getElementById("outBuy");
            if (!name) { out.innerHTML = "❌ Nome mancante."; return false; }
            if (!Number.isFinite(price) || price < 0) { out.innerHTML = "❌ Prezzo non valido."; return false; }
            const priceInt = Math.round(price);
            
            // Show price adjustment if needed
            if (price !== priceInt && Math.abs(price - priceInt) > 0.01) {
                console.log(`Price adjusted from ${price} to ${priceInt}`);
            }
            
            const playerInList = ORIGINAL ? ORIGINAL.find(p => norm(p.name) === norm(name)) : null;
            if (!playerInList) { 
                // Use textContent to prevent HTML injection
                out.innerHTML = `❌ <span class="warn"></span>`;
                out.querySelector('.warn').textContent = `"${name}" non è nella tua lista originale di giocatori.`;
                return false; 
            }
            const already = purchases.find(p => norm(p.name) === norm(name));
            if (already) { 
                out.innerHTML = `❌ <span class="warn"></span>`;
                out.querySelector('.warn').textContent = `"${name}" già acquistato (${already.price} crediti).`;
                return false; 
            }
            if (spent + priceInt > START_BUDGET) { 
                out.innerHTML = `❌ <span class="warn">Budget insufficiente. Residuo ${START_BUDGET - spent}, prezzo ${priceInt}.</span>`;
                return false; 
            }

            const over = playerInList.bid && priceInt > playerInList.bid;
            const savedCredits = playerInList.bid ? Math.max(0, playerInList.bid - priceInt) : 0;

            // Record purchase info for potential undo
            const purchaseInfo = {
                name,
                price: priceInt,
                savedCredits,
                redistributionSnapshot: null
            };

            // Save current bids before redistribution for undo capability
            if (savedCredits > 0) {
                purchaseInfo.redistributionSnapshot = roster.map(p => ({ name: p.name, bid: p.bid }));
            }

            purchases.push(purchaseInfo);
            spent += priceInt;

            // Redistribute saved credits to remaining players
            let redistributed = 0;
            if (savedCredits > 0) {
                redistributed = redistributeCredits(savedCredits, name);
            }

            const li = document.createElement("li");
            li.textContent = `${name} - ${priceInt}` + (over ? ` (>${playerInList.bid})` : "");
            li.classList.add("flash-add");
            document.getElementById("purchasesList").appendChild(li);

            let message = over ? `⚠️ Aggiunto "${name}" per ${priceInt}` : `✅ Aggiunto "${name}" per ${priceInt}`;
            if (redistributed > 0) {
                message += ` | 💰 ${redistributed} crediti ridistribuiti ai giocatori più costosi`;
            }
            
            // Sanitize name for display
            const safeMessage = document.createElement('span');
            safeMessage.innerHTML = message.replace(name, `<span class="player-name"></span>`);
            safeMessage.querySelector('.player-name').textContent = name;
            out.innerHTML = '';
            out.appendChild(safeMessage);

            updateCounters();
            return li;
        }

        function undoPurchase() {
            const out = document.getElementById("outBuy");
            if (purchases.length === 0) { out.innerHTML = "⚠️ Nessun acquisto da annullare."; return; }
            const last = purchases.pop();
            spent -= last.price;
            
            // Restore bids if redistribution happened
            if (last.redistributionSnapshot && roster) {
                last.redistributionSnapshot.forEach(snapshot => {
                    const player = roster.find(p => p.name === snapshot.name);
                    if (player) {
                        player.bid = snapshot.bid;
                    }
                });
            }
            
            const list = document.getElementById("purchasesList");
            if (list.lastChild) list.removeChild(list.lastChild);
            
            const safeMsg = document.createElement('span');
            safeMsg.textContent = `↩️ Annullato "${last.name}" per ${last.price}`;
            if (last.savedCredits > 0) {
                safeMsg.textContent += ` | Redistribuzione annullata`;
            }
            out.innerHTML = '';
            out.appendChild(safeMsg);
            
            updateCounters();
        }

        function exportCSV() {
            const out = document.getElementById("outBuy");
            if (purchases.length === 0) { out.innerHTML = "⚠️ Nessun acquisto da esportare."; return; }
            const rows = [["Nome", "Prezzo"], ...purchases.map(p => [p.name, String(p.price)])];
            rows.push(["Totale speso", String(spent)]);
            rows.push(["Residuo", String(START_BUDGET - spent)]);
            const csv = rows.map(r => r.map(x => `"${String(x).replace(/"/g, '""')}"`).join(",")).join("\n");
            const blob = new Blob([csv], { type: "text/csv;charset=utf-8;" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = `acquisti_fantacalcio_${new Date().toISOString().slice(0, 10)}.csv`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            out.innerHTML = "📦 CSV esportato.";
        }

        const $ = sel => document.querySelector(sel);

        // Unlock logic function
        async function performUnlock() {
            const pw = $("#pw").value || "";
            const out = $("#outUnlock");
            try {
                const key = await sha256Bytes(pw);
                const obf = b64ToBytes(OBF);
                const plain = deobfuscate(obf, key);
                const text = new TextDecoder().decode(plain);
                const parsed = JSON.parse(text);
                if (!Array.isArray(parsed) || parsed.length === 0) throw new Error("Formato elenco non valido.");
                ORIGINAL = parsed;
                roster = JSON.parse(JSON.stringify(ORIGINAL));
                $("#locked").style.display = "none";
                $("#app").style.display = "";
                updateCounters();
                document.getElementById("leftList").textContent = listRemaining();
            } catch (e) {
                console.error(e);
                out.innerHTML = "❌ <span class='warn'>Passphrase errata o dati corrotti.</span>";
            }
        }

        // Unlock button click
        $("#btnUnlock").addEventListener("click", performUnlock);

        // Unlock on Enter key press in password field
        $("#pw").addEventListener("keydown", (e) => {
            if (e.key === "Enter") {
                e.preventDefault();
                performUnlock();
            }
        });

        // Main event delegation
        document.addEventListener("click", ev => {
            const id = ev.target && ev.target.id;
            if (!id) return;

            if (id === "btnCheck") {
                const q = $("#q").value;
                const out = $("#outCheck");
                const auctionSection = document.getElementById("auctionSection");
                const matches = findCandidates(q);
                if (matches.length === 0) {
                    out.innerHTML = `❌ <span class="warn">"${q}" non è nella tua lista attuale.</span>`;
                    auctionSection.style.display = "none";
                    currentAuctionPlayer = null;
                    lastSuggestedBid = null;
                } else if (matches.length > 1) {
                    out.textContent = `⚠️ Trovati più match:\n- ${matches.map(m => m.name).join("\n- ")}`;
                    auctionSection.style.display = "none";
                    currentAuctionPlayer = null;
                    lastSuggestedBid = null;
                } else {
                    const player = matches[0];
                    currentAuctionPlayer = player;
                    lastSuggestedBid = null;
                    out.innerHTML = `✅ <span class="ok">${formatPlayer(player)}</span>`;
                    document.getElementById("playerInfo").innerHTML = `<strong>${player.name}</strong> (${player.role})`;
                    document.getElementById("currentOffer").value = "";
                    document.getElementById("outAuction").innerHTML = "";
                    auctionSection.style.display = "block";
                }
            }

            if (id === "btnClear") {
                $("#q").value = "";
                $("#outCheck").textContent = "";
                document.getElementById("auctionSection").style.display = "none";
                currentAuctionPlayer = null;
                lastSuggestedBid = null;
                $("#q").focus();
            }

            if (id === "btnRandom") {
                const out = $("#outRandom");
                if (!roster || roster.length === 0) {
                    out.innerHTML = "❌ Lista vuota: nessun giocatore rimanente.";
                    return;
                }
                const i = Math.floor(Math.random() * roster.length);
                const p = roster[i];
                out.innerHTML = `🎯 <strong>${p.name}</strong> - ruolo ${p.role}`;
                currentAuctionPlayer = p;
                lastSuggestedBid = null;
                const auctionSection = document.getElementById("auctionSection");
                document.getElementById("playerInfo").innerHTML = `<strong>${p.name}</strong> (${p.role})`;
                document.getElementById("currentOffer").value = "1";
                document.getElementById("outAuction").innerHTML = "";
                auctionSection.style.display = "block";
                auctionSection.scrollIntoView({ behavior: "smooth" });
            }

            if (id === "btnShowLeft") {
                const wrap = document.getElementById("leftWrap");
                const list = document.getElementById("leftList");
                if (wrap.style.display === "none") {
                    list.textContent = listRemaining();
                    wrap.style.display = "";
                } else wrap.style.display = "none";
            }

            if (id === "btnReset") {
                if (!confirm("Ripristinare la lista originale (500 totali)?")) return;
                roster = JSON.parse(JSON.stringify(ORIGINAL));
                updateCounters();
                document.getElementById("leftList").textContent = listRemaining();
                document.getElementById("outRandom").textContent = "";
                document.getElementById("outCheck").textContent = "";
                
                // Clear auction state
                currentAuctionPlayer = null;
                lastSuggestedBid = null;
                const auctionSection = document.getElementById("auctionSection");
                if (auctionSection) auctionSection.style.display = "none";
            }

            if (id === "btnReObf") {
                const newpw = $("#newpw").value || "";
                const out = $("#outReObf");
                if (!newpw) {
                    out.innerHTML = "❌ Inserisci una nuova passphrase.";
                    return;
                }
                (async () => {
                    try {
                        const key = await sha256Bytes(newpw);
                        const text = JSON.stringify(ORIGINAL);
                        const plain = new TextEncoder().encode(text);
                        const obf = obfuscate(plain, key);
                        const b64 = bytesToB64(obf);
                        out.innerHTML = "✅ Nuova stringa OBF (copiala nel file sulla variabile <code>OBF</code>):\n\n" + b64;
                    } catch (e) {
                        console.error(e);
                        out.innerHTML = "❌ Errore nella generazione.";
                    }
                })();
            }

            if (id === "btnUndoBuy") undoPurchase();

            if (id === "btnExportCSV") exportCSV();

            if (id === "btnCalculateBid") {
                if (!currentAuctionPlayer) return;
                const outAuction = document.getElementById("outAuction");
                const val = document.getElementById("currentOffer").value || "";
                if (!val) {
                    outAuction.innerHTML = "❌ Inserisci l'offerta attuale.";
                    return;
                }
                const currentOffer = Number(val);
                if (!Number.isFinite(currentOffer) || currentOffer < 1) {
                    outAuction.innerHTML = "❌ Offerta non valida.";
                    return;
                }
                const currentOfferInt = Math.round(currentOffer);
                const maxBid = currentAuctionPlayer.bid;
                if (currentOfferInt >= maxBid) {
                    // lost - redistribute credits and remove from roster
                    const lostPlayer = currentAuctionPlayer;
                    const before = roster.length;
                    roster = roster.filter(p => p.name !== currentAuctionPlayer.name);
                    let redistributed = 0;
                    if (roster.length !== before) {
                        redistributed = redistributeCreditsOnLoss(lostPlayer);
                        updateCounters();
                        if (document.getElementById("leftWrap").style.display !== "none")
                            document.getElementById("leftList").textContent = listRemaining();
                    }

                    let message = `😞 <strong>${currentAuctionPlayer.name}</strong> andato ad altri (raggiunto limite interno).`;
                    if (redistributed > 0) {
                        message += ` | 💰 ${redistributed} crediti ridistribuiti ai giocatori più costosi`;
                    }
                    outAuction.innerHTML = message;
                    lastSuggestedBid = null;
                    setTimeout(() => {
                        document.getElementById("auctionSection").style.display = "none";
                        currentAuctionPlayer = null;
                    }, 2500);
                } else {
                    // Easter egg: if max bid > 37 and current offer < 35, offer 36
                    let ourBid;
                    if (maxBid > 37 && currentOfferInt < 35) {
                        ourBid = 36;
                    } else {
                        ourBid = currentOfferInt + 1;
                    }
                    lastSuggestedBid = { player: currentAuctionPlayer.name, value: ourBid };
                    outAuction.innerHTML = `💰 <span class="ok">Offriamo: <strong>${ourBid}</strong> crediti</span>`;
                }
            }

            if (id === "btnPlayerWon") {
                if (!currentAuctionPlayer) return;
                const val = document.getElementById("currentOffer").value || "";
                const outAuction = document.getElementById("outAuction");
                if (!val) {
                    outAuction.innerHTML = "❌ Inserisci il prezzo finale di acquisto.";
                    return;
                }
                const base = Math.round(Number(val));
                if (!Number.isFinite(base) || base < 0) {
                    outAuction.innerHTML = "❌ Prezzo non valido.";
                    return;
                }
                
                // Usa il suggerimento calcolato (ourBid) se ancora valido, altrimenti assume base+1
                let finalPrice = base + 1;
                if (lastSuggestedBid && lastSuggestedBid.player === currentAuctionPlayer.name)
                    finalPrice = lastSuggestedBid.value;
                
                // CRITICAL FIX: Attempt purchase BEFORE removing from roster
                const li = addPurchase(currentAuctionPlayer.name, finalPrice);
                if (li) {
                    // Only remove from roster after successful purchase
                    const before = roster.length;
                    roster = roster.filter(p => norm(p.name) !== norm(currentAuctionPlayer.name));
                    if (roster.length !== before) {
                        updateCounters();
                        if (document.getElementById("leftWrap").style.display !== "none")
                            document.getElementById("leftList").textContent = listRemaining();
                    }
                    
                    const safeMsg = document.createElement('span');
                    safeMsg.innerHTML = `🎉 <strong></strong> acquisito, budget aggiornato e rimosso dalla lista rimanente.`;
                    safeMsg.querySelector('strong').textContent = currentAuctionPlayer.name;
                    outAuction.innerHTML = '';
                    outAuction.appendChild(safeMsg);
                    
                    li.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    setTimeout(() => li.classList.remove('flash-add'), 1600);
                    document.getElementById("auctionSection").style.display = "none";
                    currentAuctionPlayer = null;
                    lastSuggestedBid = null;
                } else {
                    // Purchase failed - auction state remains, player NOT removed
                    const safeMsg = document.createElement('span');
                    safeMsg.innerHTML = `⚠️ Verifica messaggi sotto la sezione acquisti: impossibile aggiungere <strong></strong>.`;
                    safeMsg.querySelector('strong').textContent = currentAuctionPlayer.name;
                    outAuction.innerHTML = '';
                    outAuction.appendChild(safeMsg);
                }
            }

            if (id === "btnPlayerLost") {
                if (!currentAuctionPlayer) return;
                const outAuction = document.getElementById("outAuction");
                const lostPlayer = currentAuctionPlayer;
                const before = roster.length;
                roster = roster.filter(p => p.name !== currentAuctionPlayer.name);
                let redistributed = 0;
                if (roster.length !== before) {
                    redistributed = redistributeCreditsOnLoss(lostPlayer);
                    updateCounters();
                    if (document.getElementById("leftWrap").style.display !== "none")
                        document.getElementById("leftList").textContent = listRemaining();

                    let message = `😞 <strong>${currentAuctionPlayer.name}</strong> andato ad altri e rimosso.`;
                    if (redistributed > 0) {
                        message += ` | 💰 ${redistributed} crediti ridistribuiti ai giocatori più costosi`;
                    }
                    outAuction.innerHTML = message;
                } else {
                    outAuction.innerHTML = `😞 <strong>${currentAuctionPlayer.name}</strong> andato ad altri.`;
                }
                setTimeout(() => {
                    document.getElementById("auctionSection").style.display = "none";
                    currentAuctionPlayer = null;
                }, 1800);
            }
        });

        // Embedded Test Suite for Fantasy Football Auction App
        // 🧪 Automated Test Suite for Fantasy Football Auction App
        // Run this in the browser console after unlocking the app

        class FantasyFootballTester {
            constructor() {
                this.results = [];
                this.originalRoster = null;
                this.originalPurchases = null;
                this.originalSpent = null;
            }

            // Test utilities
            log(message, type = 'info') {
                const emoji = {
                    'pass': '✅',
                    'fail': '❌',
                    'info': 'ℹ️',
                    'warn': '⚠️'
                };
                console.log(`${emoji[type]} ${message}`);
                this.results.push({ message, type });
            }

            assert(condition, testName, errorMessage = '') {
                if (condition) {
                    this.log(`PASS: ${testName}`, 'pass');
                    return true;
                } else {
                    this.log(`FAIL: ${testName} - ${errorMessage}`, 'fail');
                    return false;
                }
            }

            setup() {
                this.log('Setting up test environment...', 'info');

                // Save original state
                this.originalRoster = roster ? JSON.parse(JSON.stringify(roster)) : null;
                this.originalPurchases = [...purchases];
                this.originalSpent = spent;

                // Clear any existing state
                purchases.length = 0;
                spent = 0;
                updateCounters();

                this.log('Test environment ready', 'info');
            }

            cleanup() {
                this.log('Cleaning up test environment...', 'info');

                // Restore original state
                if (this.originalRoster) {
                    roster = JSON.parse(JSON.stringify(this.originalRoster));
                }
                purchases.length = 0;
                purchases.push(...this.originalPurchases);
                spent = this.originalSpent;

                updateCounters();
                this.log('Test environment restored', 'info');
            }

            // Test functions
            testSearchFunctionality() {
                this.log('Testing search functionality...', 'info');

                if (!roster || roster.length === 0) {
                    this.log('No roster available for testing', 'warn');
                    return;
                }

                // Test exact match
                const firstPlayer = roster[0];
                const exactResults = findCandidates(firstPlayer.name);
                this.assert(
                    exactResults.length === 1 && exactResults[0].name === firstPlayer.name,
                    'Exact player search',
                    `Expected 1 result for "${firstPlayer.name}", got ${exactResults.length}`
                );

                // Test partial match
                const partialName = firstPlayer.name.substring(0, 4);
                const partialResults = findCandidates(partialName);
                this.assert(
                    partialResults.length >= 1,
                    'Partial player search',
                    `Expected at least 1 result for "${partialName}", got ${partialResults.length}`
                );

                // Test case insensitive
                const lowerResults = findCandidates(firstPlayer.name.toLowerCase());
                this.assert(
                    lowerResults.length >= 1,
                    'Case insensitive search',
                    `Search should be case insensitive`
                );

                // Test non-existent player
                const noResults = findCandidates('NonExistentPlayer123');
                this.assert(
                    noResults.length === 0,
                    'Non-existent player search',
                    `Expected 0 results for non-existent player, got ${noResults.length}`
                );
            }

            testBidCalculation() {
                this.log('Testing bid calculation logic...', 'info');

                if (!roster || roster.length === 0) {
                    this.log('No roster available for testing', 'warn');
                    return;
                }

                // Find a player with high bid for easter egg test
                const highBidPlayer = roster.find(p => p.bid > 37);

                if (highBidPlayer) {
                    // Test easter egg (should suggest 36 when current < 35 and max > 37)
                    currentAuctionPlayer = highBidPlayer;

                    // Simulate bid calculation for easter egg
                    const currentOffer = 30;
                    const maxBid = highBidPlayer.bid;

                    let ourBid;
                    if (maxBid > 37 && currentOffer < 35) {
                        ourBid = 36;
                    } else {
                        ourBid = currentOffer + 1;
                    }

                    this.assert(
                        ourBid === 36,
                        'Easter egg bid calculation (36 credits)',
                        `Expected 36, got ${ourBid} for current=${currentOffer}, max=${maxBid}`
                    );
                }

                // Test normal bid calculation
                const normalPlayer = roster[0];
                currentAuctionPlayer = normalPlayer;
                const normalOffer = 20;
                const normalBid = normalOffer + 1;

                this.assert(
                    normalBid === 21,
                    'Normal bid calculation (+1)',
                    `Expected 21, got ${normalBid}`
                );
            }

            testPurchaseSystem() {
                this.log('Testing purchase system...', 'info');

                if (!roster || roster.length === 0) {
                    this.log('No roster available for testing', 'warn');
                    return;
                }

                const testPlayer = roster[0];
                const testPrice = 15;
                const initialSpent = spent;
                const initialLength = purchases.length;

                // Test valid purchase
                const result = addPurchase(testPlayer.name, testPrice);

                this.assert(
                    result !== false,
                    'Valid player purchase',
                    'Purchase should succeed'
                );

                this.assert(
                    spent === initialSpent + testPrice,
                    'Budget update after purchase',
                    `Expected spent to be ${initialSpent + testPrice}, got ${spent}`
                );

                this.assert(
                    purchases.length === initialLength + 1,
                    'Purchase list update',
                    `Expected ${initialLength + 1} purchases, got ${purchases.length}`
                );

                // Test duplicate purchase
                const duplicateResult = addPurchase(testPlayer.name, testPrice);
                this.assert(
                    duplicateResult === false,
                    'Prevent duplicate purchase',
                    'Should not allow buying same player twice'
                );

                // Test budget overflow
                const expensivePrice = START_BUDGET + 100;
                const overflowResult = addPurchase(roster[1]?.name || 'TestPlayer', expensivePrice);
                this.assert(
                    overflowResult === false,
                    'Prevent budget overflow',
                    'Should not allow purchases exceeding budget'
                );
            }

            testCreditRedistribution() {
                this.log('Testing credit redistribution on purchase with savings...', 'info');

                if (!roster || roster.length < 5) {
                    this.log('Insufficient roster for redistribution testing (need at least 5 players)', 'warn');
                    return;
                }

                // Save original bids
                const originalBids = roster.map(p => ({ name: p.name, bid: p.bid }));

                // Test 1: Standard redistribution - player bought for less than max bid
                this.log('Test 1: Standard purchase redistribution', 'info');
                const testPlayer = roster.find(p => p.bid >= 20) || roster[0];
                const purchasePrice = testPlayer.bid - 5; // Save 5 credits
                const savedCredits = testPlayer.bid - purchasePrice;

                // Get top players (excluding the purchased one) before redistribution
                const remainingPlayers = roster
                    .filter(p => p.name !== testPlayer.name)
                    .sort((a, b) => (b.bid || 0) - (a.bid || 0));

                const topPlayersBefore = remainingPlayers.slice(0, savedCredits);
                const topPlayersBidsBefore = topPlayersBefore.map(p => p.bid);

                // Perform redistribution
                const redistributed = redistributeCredits(savedCredits, testPlayer.name);

                // Verify redistribution count
                const expectedRedistribution = Math.min(savedCredits, remainingPlayers.length);
                this.assert(
                    redistributed === expectedRedistribution,
                    'Purchase redistribution count matches expected',
                    `Expected ${expectedRedistribution} credits redistributed, got ${redistributed}`
                );

                // Verify that top players got +1 bid each
                if (redistributed > 0) {
                    let correctDistribution = true;

                    for (let i = 0; i < redistributed; i++) {
                        const expectedNewBid = topPlayersBidsBefore[i] + 1;
                        if (topPlayersBefore[i].bid !== expectedNewBid) {
                            correctDistribution = false;
                            this.log(`Player ${topPlayersBefore[i].name}: expected ${expectedNewBid}, got ${topPlayersBefore[i].bid}`, 'warn');
                        }
                    }

                    this.assert(
                        correctDistribution,
                        'Saved credits distributed to most expensive remaining players (+1 each)',
                        'Top remaining players should each receive exactly +1 credit'
                    );
                }

                // Restore for next test
                originalBids.forEach(orig => {
                    const player = roster.find(p => p.name === orig.name);
                    if (player) player.bid = orig.bid;
                });

                // Test 2: Saved credits exceed remaining players
                this.log('Test 2: Savings exceed number of remaining players', 'info');
                const hugeSavings = roster.length + 10; // More credits than players
                const maxPossible = roster.length - 1; // Exclude purchased player
                const redistributed2 = redistributeCredits(hugeSavings, testPlayer.name);

                this.assert(
                    redistributed2 === maxPossible,
                    'Redistribution capped by remaining player count',
                    `With ${hugeSavings} savings but only ${maxPossible} other players, expected ${maxPossible} redistributed, got ${redistributed2}`
                );

                // Restore for next test
                originalBids.forEach(orig => {
                    const player = roster.find(p => p.name === orig.name);
                    if (player) player.bid = orig.bid;
                });

                // Test 3: Verify prioritization - most expensive get credits first
                this.log('Test 3: Verify prioritization of expensive players', 'info');
                const savings3 = 3; // Only 3 credits to distribute
                const sortedPlayers = [...roster]
                    .filter(p => p.name !== testPlayer.name)
                    .sort((a, b) => (b.bid || 0) - (a.bid || 0));
                const topThreeBefore = sortedPlayers.slice(0, 3).map(p => ({ name: p.name, bid: p.bid }));

                redistributeCredits(savings3, testPlayer.name);

                const topThreeAfter = sortedPlayers.slice(0, 3);
                let prioritizationCorrect = true;
                for (let i = 0; i < 3; i++) {
                    if (topThreeAfter[i].bid !== topThreeBefore[i].bid + 1) {
                        prioritizationCorrect = false;
                        this.log(`Priority error: ${topThreeAfter[i].name} expected ${topThreeBefore[i].bid + 1}, got ${topThreeAfter[i].bid}`, 'warn');
                        break;
                    }
                }

                this.assert(
                    prioritizationCorrect,
                    'Most expensive remaining players prioritized',
                    'Top 3 most expensive remaining players should each get +1 credit'
                );

                // Restore for next test
                originalBids.forEach(orig => {
                    const player = roster.find(p => p.name === orig.name);
                    if (player) player.bid = orig.bid;
                });

                // Test 4: Edge case - zero saved credits
                this.log('Test 4: Purchase at exact max bid (no savings)', 'info');
                const bidsBefore = roster.map(p => p.bid);
                const zeroSavingsResult = redistributeCredits(0, testPlayer.name);

                this.assert(
                    zeroSavingsResult === 0,
                    'No redistribution when no credits saved',
                    'Should return 0 when purchase price equals max bid'
                );

                // Verify no bids changed
                const bidsUnchanged = roster.every((p, i) => p.bid === bidsBefore[i]);
                this.assert(
                    bidsUnchanged,
                    'Player bids unchanged with zero savings',
                    'No player bids should change'
                );

                // Test 5: Edge case - negative saved credits (shouldn't happen but test safety)
                this.log('Test 5: Negative saved credits (safety check)', 'info');
                const negativeResult = redistributeCredits(-5, testPlayer.name);

                this.assert(
                    negativeResult === 0,
                    'No redistribution for negative credits',
                    'Should return 0 for negative savings'
                );

                // Test 6: Single credit saved
                this.log('Test 6: Only 1 credit saved', 'info');
                const topPlayerBefore = [...roster]
                    .filter(p => p.name !== testPlayer.name)
                    .sort((a, b) => (b.bid || 0) - (a.bid || 0))[0];
                const topPlayerBidBefore = topPlayerBefore.bid;

                const singleCredResult = redistributeCredits(1, testPlayer.name);

                this.assert(
                    singleCredResult === 1,
                    'Exactly 1 credit redistributed',
                    `Expected 1 credit redistributed, got ${singleCredResult}`
                );

                this.assert(
                    topPlayerBefore.bid === topPlayerBidBefore + 1,
                    'Single saved credit goes to most expensive remaining player',
                    `Top player should have ${topPlayerBidBefore + 1}, got ${topPlayerBefore.bid}`
                );

                // Test 7: Verify purchased player is excluded from redistribution
                this.log('Test 7: Verify purchased player excluded from redistribution', 'info');
                originalBids.forEach(orig => {
                    const player = roster.find(p => p.name === orig.name);
                    if (player) player.bid = orig.bid;
                });

                const purchasedPlayerBidBefore = testPlayer.bid;
                redistributeCredits(10, testPlayer.name);

                this.assert(
                    testPlayer.bid === purchasedPlayerBidBefore,
                    'Purchased player bid unchanged',
                    `Purchased player "${testPlayer.name}" should not receive redistributed credits`
                );

                // Restore original bids
                originalBids.forEach(orig => {
                    const player = roster.find(p => p.name === orig.name);
                    if (player) player.bid = orig.bid;
                });

                this.log('Credit redistribution on purchase tests completed', 'info');
            }

            testCreditRedistributionOnLoss() {
                this.log('Testing credit redistribution on player loss...', 'info');

                if (!roster || roster.length < 5) {
                    this.log('Insufficient roster for loss redistribution testing (need at least 5 players)', 'warn');
                    return;
                }

                // Save original state
                const originalBids = roster.map(p => ({ name: p.name, bid: p.bid }));

                // Test 1: Standard redistribution with enough players
                this.log('Test 1: Standard loss redistribution', 'info');
                const lostPlayer = roster.find(p => p.bid >= 20) || roster[0];
                const lostPlayerBid = lostPlayer.bid;

                // Get the top players before redistribution (excluding the lost player)
                const remainingPlayersBeforeLoss = roster
                    .filter(p => p.name !== lostPlayer.name)
                    .sort((a, b) => (b.bid || 0) - (a.bid || 0));

                const topPlayersBefore = remainingPlayersBeforeLoss.slice(0, Math.min(lostPlayerBid, remainingPlayersBeforeLoss.length));
                const topPlayersBidsBefore = topPlayersBefore.map(p => p.bid);

                // Perform redistribution on loss
                const redistributed = redistributeCreditsOnLoss(lostPlayer);

                // Verify the redistribution count
                const expectedRedistribution = Math.min(lostPlayerBid, remainingPlayersBeforeLoss.length);
                this.assert(
                    redistributed === expectedRedistribution,
                    'Loss redistribution count matches expected',
                    `Expected ${expectedRedistribution} credits redistributed, got ${redistributed}`
                );

                // Verify that top players got +1 bid each
                if (redistributed > 0) {
                    let correctDistribution = true;

                    for (let i = 0; i < redistributed; i++) {
                        const expectedNewBid = topPlayersBidsBefore[i] + 1;
                        if (topPlayersBefore[i].bid !== expectedNewBid) {
                            correctDistribution = false;
                            this.log(`Player ${topPlayersBefore[i].name}: expected ${expectedNewBid}, got ${topPlayersBefore[i].bid}`, 'warn');
                        }
                    }

                    this.assert(
                        correctDistribution,
                        'Credits distributed to most expensive players (+1 each)',
                        'Top players should each receive exactly +1 credit'
                    );
                }

                // Restore original bids for next test
                originalBids.forEach(orig => {
                    const player = roster.find(p => p.name === orig.name);
                    if (player) player.bid = orig.bid;
                });

                // Test 2: Loss with more credits than remaining players
                this.log('Test 2: Loss with more credits than available players', 'info');
                const highBidPlayer = { name: 'HighBidTest', bid: 100, role: 'A' };
                const maxPossible = roster.length;
                const redistributed2 = redistributeCreditsOnLoss(highBidPlayer);

                this.assert(
                    redistributed2 === maxPossible,
                    'Redistribution capped by number of remaining players',
                    `With ${highBidPlayer.bid} credits but only ${maxPossible} players, expected ${maxPossible} redistributed, got ${redistributed2}`
                );

                // Restore for next test
                originalBids.forEach(orig => {
                    const player = roster.find(p => p.name === orig.name);
                    if (player) player.bid = orig.bid;
                });

                // Test 3: Verify prioritization - most expensive players get credits first
                this.log('Test 3: Verify prioritization of expensive players', 'info');
                const testLostPlayer = { name: 'TestPlayer', bid: 3, role: 'D' };
                const sortedBefore = [...roster].sort((a, b) => (b.bid || 0) - (a.bid || 0));
                const topThreeBefore = sortedBefore.slice(0, 3).map(p => ({ name: p.name, bid: p.bid }));

                redistributeCreditsOnLoss(testLostPlayer);

                const topThreeAfter = sortedBefore.slice(0, 3);
                let prioritizationCorrect = true;
                for (let i = 0; i < 3; i++) {
                    if (topThreeAfter[i].bid !== topThreeBefore[i].bid + 1) {
                        prioritizationCorrect = false;
                        break;
                    }
                }

                this.assert(
                    prioritizationCorrect,
                    'Most expensive players prioritized for credit distribution',
                    'Top 3 most expensive players should each get +1 credit'
                );

                // Restore for next test
                originalBids.forEach(orig => {
                    const player = roster.find(p => p.name === orig.name);
                    if (player) player.bid = orig.bid;
                });

                // Test 4: Edge case - player with 0 bid
                this.log('Test 4: Loss of player with zero bid', 'info');
                const zeroBidPlayer = { name: 'ZeroBid', bid: 0, role: 'P' };
                const bidsBefore = roster.map(p => p.bid);
                const zeroBidResult = redistributeCreditsOnLoss(zeroBidPlayer);

                this.assert(
                    zeroBidResult === 0,
                    'No redistribution for zero bid player',
                    'Should return 0 when lost player has no bid'
                );

                // Verify no bids changed
                const bidsUnchanged = roster.every((p, i) => p.bid === bidsBefore[i]);
                this.assert(
                    bidsUnchanged,
                    'Player bids unchanged when losing zero bid player',
                    'No player bids should change'
                );

                // Test 5: Edge case - player with 1 credit (only top player gets +1)
                this.log('Test 5: Loss of player with 1 credit bid', 'info');
                const oneCreditPlayer = { name: 'OneCredit', bid: 1, role: 'P' };
                const topPlayerBefore = [...roster].sort((a, b) => (b.bid || 0) - (a.bid || 0))[0];
                const topPlayerBidBefore = topPlayerBefore.bid;

                const oneCredResult = redistributeCreditsOnLoss(oneCreditPlayer);

                this.assert(
                    oneCredResult === 1,
                    'Exactly 1 credit redistributed for 1-bid player',
                    `Expected 1 credit redistributed, got ${oneCredResult}`
                );

                this.assert(
                    topPlayerBefore.bid === topPlayerBidBefore + 1,
                    'Single credit goes to most expensive player',
                    `Top player should have ${topPlayerBidBefore + 1}, got ${topPlayerBefore.bid}`
                );

                // Restore original bids
                originalBids.forEach(orig => {
                    const player = roster.find(p => p.name === orig.name);
                    if (player) player.bid = orig.bid;
                });

                this.log('Credit redistribution on loss tests completed', 'info');
            }

            testLossScenarios() {
                this.log('Testing loss scenarios with redistribution...', 'info');

                if (!roster || roster.length < 5) {
                    this.log('Insufficient roster for loss scenario testing (need at least 5 players)', 'warn');
                    return;
                }

                // Save original state
                const originalRoster = JSON.parse(JSON.stringify(roster));
                const originalBids = roster.map(p => ({ name: p.name, bid: p.bid }));

                // Test 1: Player lost through manual "Player Lost" button
                this.log('Test 1: Manual player loss with redistribution', 'info');
                const testPlayer = roster[0];
                const originalBid = testPlayer.bid;
                const originalRosterLength = roster.length;

                // Get remaining players before loss (sorted by bid)
                const remainingBefore = roster
                    .filter(p => p.name !== testPlayer.name)
                    .sort((a, b) => (b.bid || 0) - (a.bid || 0));

                const topPlayersBefore = remainingBefore.slice(0, Math.min(originalBid, remainingBefore.length));
                const topPlayersBidsBefore = topPlayersBefore.map(p => p.bid);

                // Simulate the loss and redistribution
                const lostPlayer = testPlayer;
                roster = roster.filter(p => p.name !== testPlayer.name);
                const redistributed = redistributeCreditsOnLoss(lostPlayer);

                // Verify roster reduction
                this.assert(
                    roster.length === originalRosterLength - 1,
                    'Roster size reduced by 1 on loss',
                    `Expected roster to shrink from ${originalRosterLength} to ${originalRosterLength - 1}, got ${roster.length}`
                );

                // Verify redistribution occurred correctly
                if (originalBid > 0 && redistributed > 0) {
                    let allCorrect = true;
                    for (let i = 0; i < redistributed; i++) {
                        const playerAfter = roster.find(p => p.name === topPlayersBefore[i].name);
                        if (playerAfter && playerAfter.bid !== topPlayersBidsBefore[i] + 1) {
                            allCorrect = false;
                            break;
                        }
                    }

                    this.assert(
                        allCorrect,
                        'Credits correctly redistributed after manual loss',
                        `Top ${redistributed} players should each gain +1 credit`
                    );
                }

                // Restore for next test
                roster = JSON.parse(JSON.stringify(originalRoster));

                // Test 2: Player lost through bid limit reached
                this.log('Test 2: Player lost due to bid limit reached', 'info');
                const highBidPlayer = roster.find(p => p.bid >= 25) || roster[0];
                const playerBid = highBidPlayer.bid;
                const beforeLoss = roster.length;

                // Get top players before this loss
                const remainingBefore2 = roster
                    .filter(p => p.name !== highBidPlayer.name)
                    .sort((a, b) => (b.bid || 0) - (a.bid || 0));
                const topBefore2 = remainingBefore2.slice(0, Math.min(playerBid, remainingBefore2.length));

                // Simulate reaching bid limit
                roster = roster.filter(p => p.name !== highBidPlayer.name);
                const redistributed2 = redistributeCreditsOnLoss(highBidPlayer);

                this.assert(
                    redistributed2 <= playerBid,
                    'Redistribution amount within lost player bid',
                    `Redistributed ${redistributed2} should not exceed lost player bid ${playerBid}`
                );

                this.assert(
                    redistributed2 <= beforeLoss - 1,
                    'Redistribution count within remaining players',
                    `Redistributed to ${redistributed2} players should not exceed remaining ${beforeLoss - 1}`
                );

                this.assert(
                    redistributed2 === Math.min(playerBid, beforeLoss - 1),
                    'Optimal redistribution count',
                    `Should redistribute ${Math.min(playerBid, beforeLoss - 1)}, got ${redistributed2}`
                );

                // Restore for next test
                roster = JSON.parse(JSON.stringify(originalRoster));

                // Test 3: Multiple sequential losses
                this.log('Test 3: Multiple sequential losses with cumulative redistribution', 'info');
                const totalBidsBefore = sumBid(roster);
                
                // Lose first player
                const loss1 = roster[0];
                const bid1 = loss1.bid;
                roster = roster.filter(p => p.name !== loss1.name);
                redistributeCreditsOnLoss(loss1);
                
                // Lose second player
                const loss2 = roster[0];
                const bid2 = loss2.bid;
                roster = roster.filter(p => p.name !== loss2.name);
                redistributeCreditsOnLoss(loss2);

                const totalBidsAfter = sumBid(roster);
                const expectedBidsAfter = totalBidsBefore - bid1 - bid2 + 
                    Math.min(bid1, originalRosterLength - 1) + 
                    Math.min(bid2, originalRosterLength - 2);

                this.assert(
                    totalBidsAfter === expectedBidsAfter,
                    'Total bids conserved through multiple losses',
                    `Expected total bids ${expectedBidsAfter}, got ${totalBidsAfter}`
                );

                // Restore for next test
                roster = JSON.parse(JSON.stringify(originalRoster));

                // Test 4: Loss followed by purchase redistribution
                this.log('Test 4: Loss followed by purchase with savings', 'info');
                
                // First lose a player
                const lossPlayer = roster.find(p => p.bid >= 15) || roster[0];
                roster = roster.filter(p => p.name !== lossPlayer.name);
                redistributeCreditsOnLoss(lossPlayer);
                const totalAfterLoss = sumBid(roster);

                // Then acquire a player for less than max bid
                const purchasePlayer = roster.find(p => p.bid >= 20) || roster[0];
                const savings = 5;
                redistributeCredits(savings, purchasePlayer.name);
                const totalAfterPurchase = sumBid(roster);

                // Total should increase by the redistributed amount
                const expectedIncrease = Math.min(savings, roster.filter(p => p.name !== purchasePlayer.name).length);
                this.assert(
                    totalAfterPurchase === totalAfterLoss + expectedIncrease,
                    'Correct bid total after loss and purchase combo',
                    `Expected total ${totalAfterLoss + expectedIncrease}, got ${totalAfterPurchase}`
                );

                // Restore original roster and bids
                roster = originalRoster;
                originalBids.forEach(orig => {
                    const player = roster.find(p => p.name === orig.name);
                    if (player) player.bid = orig.bid;
                });

                this.log('Loss scenario tests completed', 'info');
            }

            testCounters() {
                this.log('Testing counter updates...', 'info');

                if (!roster) {
                    this.log('No roster available for counter testing', 'warn');
                    return;
                }

                const counts = countsByRole(roster);
                const expectedTotal = counts.P + counts.D + counts.C + counts.A;

                this.assert(
                    expectedTotal === roster.length,
                    'Role counter accuracy',
                    `Role counts (${expectedTotal}) should equal roster length (${roster.length})`
                );

                const sumBids = sumBid(roster);
                this.assert(
                    typeof sumBids === 'number' && sumBids >= 0,
                    'Bid sum calculation',
                    `Sum of bids should be a positive number, got ${sumBids}`
                );
            }

            testUtilityFunctions() {
                this.log('Testing utility functions...', 'info');

                // Test normalization
                const testCases = [
                    ['Nicolò', 'nicolo'],
                    ['José', 'jose'],
                    ['  Spaced Name  ', 'spaced name'],
                    ['UPPERCASE', 'uppercase']
                ];

                testCases.forEach(([input, expected]) => {
                    const result = norm(input);
                    this.assert(
                        result === expected,
                        `Normalization: "${input}" → "${expected}"`,
                        `Got "${result}" instead of "${expected}"`
                    );
                });
            }

            testUndoFunctionality() {
                this.log('Testing undo functionality with redistribution rollback...', 'info');

                if (!roster || roster.length < 5) {
                    this.log('Insufficient roster for undo testing', 'warn');
                    return;
                }

                // Save original state
                const originalBids = roster.map(p => ({ name: p.name, bid: p.bid }));
                const originalSpent = spent;
                const originalPurchasesCount = purchases.length;

                // Test 1: Undo purchase with redistribution
                this.log('Test 1: Undo purchase that had credit redistribution', 'info');
                const testPlayer = roster.find(p => p.bid >= 20) || roster[0];
                const purchasePrice = testPlayer.bid - 5; // Save 5 credits
                
                // Take snapshot of bids before purchase
                const bidsBeforePurchase = roster.map(p => ({ name: p.name, bid: p.bid }));
                
                // Make purchase (triggers redistribution)
                const li = addPurchase(testPlayer.name, purchasePrice);
                this.assert(li !== false, 'Purchase succeeded', 'Purchase should succeed');

                // Verify redistribution occurred
                let redistributionOccurred = false;
                roster.forEach((p, i) => {
                    if (p.name !== testPlayer.name && p.bid !== bidsBeforePurchase[i].bid) {
                        redistributionOccurred = true;
                    }
                });

                // Now undo the purchase
                undoPurchase();

                // Verify bids rolled back
                let rollbackSucceeded = true;
                bidsBeforePurchase.forEach(snapshot => {
                    const player = roster.find(p => p.name === snapshot.name);
                    if (player && player.bid !== snapshot.bid) {
                        rollbackSucceeded = false;
                        this.log(`Rollback failed for ${player.name}: expected ${snapshot.bid}, got ${player.bid}`, 'warn');
                    }
                });

                this.assert(
                    rollbackSucceeded,
                    'Bids correctly rolled back after undo',
                    'All player bids should return to pre-purchase values'
                );

                this.assert(
                    spent === originalSpent,
                    'Spent credits restored after undo',
                    `Expected ${originalSpent}, got ${spent}`
                );

                this.assert(
                    purchases.length === originalPurchasesCount,
                    'Purchase list restored after undo',
                    `Expected ${originalPurchasesCount} purchases, got ${purchases.length}`
                );

                // Test 2: Undo purchase without redistribution (bought at max bid)
                this.log('Test 2: Undo purchase with no redistribution', 'info');
                const exactBidPlayer = roster[0];
                const exactPrice = exactBidPlayer.bid;
                const bidsBefore = roster.map(p => ({ name: p.name, bid: p.bid }));
                
                addPurchase(exactBidPlayer.name, exactPrice);
                undoPurchase();

                let bidsUnchanged = true;
                bidsBefore.forEach(snapshot => {
                    const player = roster.find(p => p.name === snapshot.name);
                    if (player && player.bid !== snapshot.bid) {
                        bidsUnchanged = false;
                    }
                });

                this.assert(
                    bidsUnchanged,
                    'No bid changes for exact-price purchase undo',
                    'Bids should remain unchanged'
                );

                // Test 3: Multiple undo operations
                this.log('Test 3: Multiple sequential undo operations', 'info');
                const player1 = roster.find(p => p.bid >= 15) || roster[0];
                const player2 = roster.find(p => p.bid >= 15 && p.name !== player1.name) || roster[1];
                
                const initialBids = roster.map(p => ({ name: p.name, bid: p.bid }));
                
                addPurchase(player1.name, player1.bid - 3);
                addPurchase(player2.name, player2.bid - 2);
                
                undoPurchase(); // Undo player2
                undoPurchase(); // Undo player1

                let multiUndoSuccess = true;
                initialBids.forEach(snapshot => {
                    const player = roster.find(p => p.name === snapshot.name);
                    if (player && player.bid !== snapshot.bid) {
                        multiUndoSuccess = false;
                    }
                });

                this.assert(
                    multiUndoSuccess,
                    'Multiple undo operations restore state correctly',
                    'All bids should return to initial state'
                );

                // Restore original state
                originalBids.forEach(orig => {
                    const player = roster.find(p => p.name === orig.name);
                    if (player) player.bid = orig.bid;
                });
                purchases.length = 0;
                spent = 0;

                this.log('Undo functionality tests completed', 'info');
            }

            testEdgeCases() {
                this.log('Testing edge cases and error handling...', 'info');

                if (!roster || roster.length < 3) {
                    this.log('Insufficient roster for edge case testing', 'warn');
                    return;
                }

                // Test 1: Decimal price handling
                this.log('Test 1: Decimal/fractional prices', 'info');
                const player1 = roster[0];
                const decimalPrice = 15.7;
                const beforePurchases = purchases.length;
                
                addPurchase(player1.name, decimalPrice);
                
                if (purchases.length > beforePurchases) {
                    const lastPurchase = purchases[purchases.length - 1];
                    this.assert(
                        lastPurchase.price === Math.round(decimalPrice),
                        'Decimal price rounded correctly',
                        `Expected ${Math.round(decimalPrice)}, got ${lastPurchase.price}`
                    );
                    undoPurchase(); // Clean up
                }

                // Test 2: Negative price
                this.log('Test 2: Negative price rejection', 'info');
                const beforeLen = purchases.length;
                const result = addPurchase(roster[0].name, -10);
                this.assert(
                    result === false,
                    'Negative price rejected',
                    'Should not allow negative prices'
                );
                this.assert(
                    purchases.length === beforeLen,
                    'Purchase list unchanged for negative price',
                    'No purchase should be added'
                );

                // Test 3: Empty player name
                this.log('Test 3: Empty player name rejection', 'info');
                const emptyResult = addPurchase('', 20);
                this.assert(
                    emptyResult === false,
                    'Empty player name rejected',
                    'Should not allow empty names'
                );

                // Test 4: Non-existent player
                this.log('Test 4: Non-existent player rejection', 'info');
                const fakeResult = addPurchase('NonExistentPlayer999', 20);
                this.assert(
                    fakeResult === false,
                    'Non-existent player rejected',
                    'Should only allow players from original list'
                );

                // Test 5: Duplicate purchase
                this.log('Test 5: Duplicate purchase prevention', 'info');
                const dupPlayer = roster[1];
                addPurchase(dupPlayer.name, 10);
                const dupResult = addPurchase(dupPlayer.name, 15);
                this.assert(
                    dupResult === false,
                    'Duplicate purchase prevented',
                    'Should not allow buying same player twice'
                );
                undoPurchase(); // Clean up

                // Test 6: Budget exceeded
                this.log('Test 6: Budget overflow prevention', 'info');
                const overflowResult = addPurchase(roster[2].name, START_BUDGET + 100);
                this.assert(
                    overflowResult === false,
                    'Budget overflow prevented',
                    'Should not allow purchases exceeding budget'
                );

                // Test 7: Undo when no purchases
                this.log('Test 7: Undo with empty purchase list', 'info');
                purchases.length = 0;
                spent = 0;
                undoPurchase(); // Should not crash
                this.assert(
                    true,
                    'Undo on empty list handled gracefully',
                    'Should not throw error'
                );

                // Test 8: Zero price
                this.log('Test 8: Zero price handling', 'info');
                const zeroResult = addPurchase(roster[0].name, 0);
                // Zero is technically valid (free agent)
                if (zeroResult !== false) {
                    this.assert(
                        purchases[purchases.length - 1].price === 0,
                        'Zero price accepted',
                        'Free agents (price 0) should be allowed'
                    );
                    undoPurchase();
                }

                this.log('Edge case tests completed', 'info');
            }

            testCSVExport() {
                this.log('Testing CSV export functionality...', 'info');

                if (!roster || roster.length < 2) {
                    this.log('Insufficient roster for CSV testing', 'warn');
                    return;
                }

                // Test 1: Export with purchases
                this.log('Test 1: CSV export with data', 'info');
                const player1 = roster[0];
                const player2 = roster[1];
                
                addPurchase(player1.name, 25);
                addPurchase(player2.name, 30);

                // We can't fully test file download in automated tests,
                // but we can verify the function doesn't crash
                try {
                    exportCSV();
                    this.assert(
                        true,
                        'CSV export executed without errors',
                        'Export function should complete'
                    );
                } catch (e) {
                    this.assert(
                        false,
                        'CSV export executed without errors',
                        `Export threw error: ${e.message}`
                    );
                }

                undoPurchase();
                undoPurchase();

                // Test 2: Export with no purchases
                this.log('Test 2: CSV export with empty purchases', 'info');
                purchases.length = 0;
                spent = 0;
                // Should show warning, not crash
                exportCSV();
                this.assert(
                    true,
                    'Empty CSV export handled gracefully',
                    'Should show warning without crashing'
                );

                this.log('CSV export tests completed', 'info');
            }

            testComplexWorkflows() {
                this.log('Testing complex multi-step workflows...', 'info');

                if (!roster || roster.length < 10) {
                    this.log('Insufficient roster for workflow testing', 'warn');
                    return;
                }

                // Save initial state
                const initialBids = roster.map(p => ({ name: p.name, bid: p.bid }));
                const initialRosterSize = roster.length;

                // Test 1: Complete auction workflow
                this.log('Test 1: Complete auction workflow (search → bid → purchase)', 'info');
                const player1 = roster.find(p => p.bid >= 20) || roster[0];
                
                // Simulate search
                const matches = findCandidates(player1.name);
                this.assert(
                    matches.length >= 1,
                    'Player found in search',
                    'Search should find player'
                );

                // Simulate purchase with savings
                const purchasePrice = player1.bid - 5;
                const bidsBeforePurchase = roster.map(p => ({ name: p.name, bid: p.bid }));
                const purchaseResult = addPurchase(player1.name, purchasePrice);
                
                this.assert(
                    purchaseResult !== false,
                    'Purchase succeeded in workflow',
                    'Player should be purchased successfully'
                );

                // Simulate roster removal (as done by btnPlayerWon)
                const beforeRemoval = roster.length;
                roster = roster.filter(p => norm(p.name) !== norm(player1.name));
                
                this.assert(
                    roster.length === beforeRemoval - 1,
                    'Player removed from roster after purchase',
                    'Roster size should decrease by 1'
                );

                // Test 2: Loss workflow with redistribution
                this.log('Test 2: Complete loss workflow (bid → lose → redistribute)', 'info');
                const player2 = roster.find(p => p.bid >= 15) || roster[0];
                const player2Bid = player2.bid;
                const bidsBeforeLoss = roster.filter(p => p.name !== player2.name).map(p => ({ name: p.name, bid: p.bid }));
                
                // Simulate loss
                roster = roster.filter(p => p.name !== player2.name);
                redistributeCreditsOnLoss(player2);

                // Verify some players got +1
                let someGotIncrease = false;
                bidsBeforeLoss.forEach(snapshot => {
                    const player = roster.find(p => p.name === snapshot.name);
                    if (player && player.bid > snapshot.bid) {
                        someGotIncrease = true;
                    }
                });

                this.assert(
                    player2Bid === 0 || someGotIncrease,
                    'Credits redistributed after loss',
                    'Some players should receive redistributed credits'
                );

                // Test 3: Purchase → Undo → Purchase different player
                this.log('Test 3: Purchase-Undo-Purchase workflow', 'info');
                
                // Restore roster
                roster = JSON.parse(JSON.stringify(this.originalRoster));
                initialBids.forEach(orig => {
                    const player = roster.find(p => p.name === orig.name);
                    if (player) player.bid = orig.bid;
                });
                purchases.length = 0;
                spent = 0;

                const player3 = roster.find(p => p.bid >= 20) || roster[0];
                const player4 = roster.find(p => p.bid >= 20 && p.name !== player3.name) || roster[1];
                
                addPurchase(player3.name, player3.bid - 3);
                const spentAfterFirst = spent;
                
                undoPurchase();
                this.assert(
                    spent < spentAfterFirst,
                    'Spent reduced after undo',
                    'Budget should be restored'
                );

                addPurchase(player4.name, player4.bid - 2);
                this.assert(
                    purchases.length === 1 && purchases[0].name === player4.name,
                    'Second purchase succeeded after undo',
                    'Should be able to purchase different player'
                );

                // Test 4: Multiple purchases with cumulative redistribution
                this.log('Test 4: Multiple purchases with cumulative redistribution', 'info');
                
                // Restore
                roster = JSON.parse(JSON.stringify(this.originalRoster));
                initialBids.forEach(orig => {
                    const player = roster.find(p => p.name === orig.name);
                    if (player) player.bid = orig.bid;
                });
                purchases.length = 0;
                spent = 0;

                const totalBidsBefore = sumBid(roster);
                
                // Make 3 purchases with savings
                const p1 = roster.find(p => p.bid >= 20) || roster[0];
                const p2 = roster.find(p => p.bid >= 20 && p.name !== p1.name) || roster[1];
                const p3 = roster.find(p => p.bid >= 20 && p.name !== p1.name && p.name !== p2.name) || roster[2];
                
                addPurchase(p1.name, p1.bid - 3);
                roster = roster.filter(p => norm(p.name) !== norm(p1.name));
                
                addPurchase(p2.name, p2.bid - 2);
                roster = roster.filter(p => norm(p.name) !== norm(p2.name));
                
                addPurchase(p3.name, p3.bid - 1);
                roster = roster.filter(p => norm(p.name) !== norm(p3.name));

                const totalBidsAfter = sumBid(roster);
                
                // Total bids should have increased due to redistribution
                this.assert(
                    totalBidsAfter > totalBidsBefore - (p1.bid + p2.bid + p3.bid),
                    'Cumulative redistribution increases total bids',
                    'Multiple purchases with savings should boost remaining players'
                );

                // Restore original state
                roster = JSON.parse(JSON.stringify(this.originalRoster));
                initialBids.forEach(orig => {
                    const player = roster.find(p => p.name === orig.name);
                    if (player) player.bid = orig.bid;
                });
                purchases.length = 0;
                spent = 0;

                this.log('Complex workflow tests completed', 'info');
            }

            testDataIntegrity() {
                this.log('Testing data integrity and state consistency...', 'info');

                if (!roster || roster.length < 5) {
                    this.log('Insufficient roster for integrity testing', 'warn');
                    return;
                }

                // Test 1: Roster immutability during redistribution
                this.log('Test 1: Roster player objects remain valid after redistribution', 'info');
                const playerRefs = roster.slice(0, 3);
                const player1 = roster.find(p => p.bid >= 20) || roster[0];
                
                redistributeCredits(5, player1.name);
                
                // Check that player objects are still in roster
                let refsValid = true;
                playerRefs.forEach(ref => {
                    if (!roster.includes(ref)) {
                        refsValid = false;
                    }
                });

                this.assert(
                    refsValid,
                    'Player object references remain valid',
                    'Redistribution should modify objects in-place, not replace them'
                );

                // Test 2: Purchase data structure integrity
                this.log('Test 2: Purchase data structure contains required fields', 'info');
                purchases.length = 0;
                spent = 0;
                
                const testPlayer = roster[0];
                addPurchase(testPlayer.name, testPlayer.bid - 3);

                if (purchases.length > 0) {
                    const purchase = purchases[0];
                    this.assert(
                        purchase.hasOwnProperty('name'),
                        'Purchase has name field',
                        'Purchase object should have name'
                    );
                    this.assert(
                        purchase.hasOwnProperty('price'),
                        'Purchase has price field',
                        'Purchase object should have price'
                    );
                    this.assert(
                        purchase.hasOwnProperty('savedCredits'),
                        'Purchase has savedCredits field',
                        'Purchase object should track saved credits'
                    );
                    this.assert(
                        purchase.hasOwnProperty('redistributionSnapshot'),
                        'Purchase has redistributionSnapshot field',
                        'Purchase object should save snapshot for undo'
                    );
                    
                    undoPurchase();
                }

                // Test 3: Counter consistency
                this.log('Test 3: Counter values match actual data', 'info');
                purchases.length = 0;
                spent = 0;
                updateCounters();
                
                const displayedBudget = parseInt(document.getElementById('budgetLeft').textContent.match(/\d+/)[0]);
                const expectedBudget = START_BUDGET - spent;
                
                this.assert(
                    displayedBudget === expectedBudget,
                    'Budget counter matches spent value',
                    `Expected ${expectedBudget}, displayed ${displayedBudget}`
                );

                this.log('Data integrity tests completed', 'info');
            }

            // Run all tests
            async runAllTests() {
                console.clear();
                this.log('🧪 Starting Fantasy Football App Test Suite', 'info');
                this.log('='.repeat(50), 'info');

                // Check if app is unlocked
                if (!ORIGINAL || !roster) {
                    this.log('❌ App not unlocked! Please unlock the app first.', 'fail');
                    return;
                }

                this.setup();

                try {
                    this.testUtilityFunctions();
                    this.testSearchFunctionality();
                    this.testBidCalculation();
                    this.testCounters();
                    this.testEdgeCases();
                    this.testUndoFunctionality();
                    this.testCreditRedistribution();
                    this.testCreditRedistributionOnLoss();
                    this.testLossScenarios();
                    this.testPurchaseSystem();
                    this.testCSVExport();
                    this.testComplexWorkflows();
                    this.testDataIntegrity();
                } catch (error) {
                    this.log(`Test suite error: ${error.message}`, 'fail');
                    console.error('Full error:', error);
                } finally {
                    this.cleanup();
                }

                // Summary
                this.log('='.repeat(50), 'info');
                const passed = this.results.filter(r => r.type === 'pass').length;
                const failed = this.results.filter(r => r.type === 'fail').length;
                const total = passed + failed;

                this.log(`Test Results: ${passed}/${total} passed`, passed === total ? 'pass' : 'fail');

                if (failed > 0) {
                    this.log('Some tests failed. Check the console output above for details.', 'warn');
                } else {
                    this.log('All tests passed! 🎉', 'pass');
                }

                return { passed, failed, total, results: this.results };
            }
        }

        // Make tester available globally
        window.FantasyTester = new FantasyFootballTester();

        // Quick test function
        window.runTests = () => window.FantasyTester.runAllTests();

        console.log('🧪 Fantasy Football Test Suite loaded!');
        console.log('📋 Usage:');
        console.log('  runTests() - Run all tests (recommended)');
        console.log('');
        console.log('📚 Available test modules:');
        console.log('  FantasyTester.testSearchFunctionality() - Player search tests');
        console.log('  FantasyTester.testCreditRedistribution() - Purchase redistribution tests');
        console.log('  FantasyTester.testCreditRedistributionOnLoss() - Loss redistribution tests');
        console.log('  FantasyTester.testLossScenarios() - Complete loss scenarios');
        console.log('  FantasyTester.testUndoFunctionality() - Undo with rollback tests');
        console.log('  FantasyTester.testEdgeCases() - Edge cases and error handling');
        console.log('  FantasyTester.testComplexWorkflows() - Multi-step workflows');
        console.log('  FantasyTester.testDataIntegrity() - Data consistency tests');
        console.log('  FantasyTester.testCSVExport() - CSV export validation');
        console.log('');
        console.log('⚠️  Make sure to unlock the app first with passphrase: "dammi un Braulio"');
        console.log('🔍 Total test coverage: 60+ assertions across 13 test modules');
    </script>

</body>

</html>